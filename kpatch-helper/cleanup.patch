diff -ruN linux-2.6.20-synusb/drivers/usb/input/synaptics-usb.c linux-2.6.20-synusb-cleanup/drivers/usb/input/synaptics-usb.c
--- linux-2.6.20-synusb/drivers/usb/input/synaptics-usb.c	2007-03-12 16:19:51.000000000 +0100
+++ linux-2.6.20-synusb-cleanup/drivers/usb/input/synaptics-usb.c	2007-03-12 16:25:51.000000000 +0100
@@ -32,11 +32,6 @@
  * check coding style and comments
  */
 
-#include "synusb-kcompat.h"
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
-#include <linux/config.h>
-#endif
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/init.h>
@@ -44,14 +39,8 @@
 #include <linux/module.h>
 #include <asm/uaccess.h>
 #include <linux/usb.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,18)
 #include <linux/usb/input.h>
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,13)
-#include <linux/usb_input.h>
-#endif
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,5)
 #include <linux/kref.h>
-#endif
 #include <linux/input.h>
 #include <linux/workqueue.h>
 #include <linux/moduleparam.h>
@@ -160,11 +149,7 @@
 
 static char synusb_input_name[] = "Synaptics USB touchpad";
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
 static void synusb_input_callback(struct urb *urb)
-#else
-static void synusb_input_callback(struct urb *urb, struct pt_regs *regs)
-#endif
 {
 	struct synusb *synusb = (struct synusb *)urb->context;
 	unsigned char *data = urb->transfer_buffer;
@@ -203,10 +188,6 @@
 		tool_width = 0;
 	}
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
-	input_regs (idev, regs);
-#endif
-
 	if (pressure > 30) input_report_key (idev, BTN_TOUCH, 1);
 	if (pressure < 25) input_report_key (idev, BTN_TOUCH, 0);
 
@@ -236,11 +217,7 @@
 /* data must always be fetched from the int endpoint, otherwise the touchpad
  * would reconnect to force driver reload, so this is always scheduled by probe
  */
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static void synusb_submit_int(void *work)
-#else
 static void synusb_submit_int(struct work_struct *work)
-#endif
 {
 	struct synusb *synusb = container_of(work, struct synusb, isubmit.work);
 	int res;
@@ -286,11 +263,7 @@
 	idev->phys = synusb->iphys;
 	idev->name = synusb_input_name;
 	usb_to_input_id(udev, &idev->id);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
 	idev->cdev.dev = &synusb->interface->dev;
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,2)
-	idev->dev = &synusb->interface->dev;
-#endif
 
 	input_register_device(idev);
 
@@ -433,11 +406,7 @@
 	return retval;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
 static void cpad_in_callback(struct urb *urb)
-#else
-static void cpad_in_callback(struct urb *urb, struct pt_regs *regs)
-#endif
 {
 	struct synusb *synusb;
 
@@ -447,11 +416,7 @@
 	wake_up_interruptible(&synusb->wait);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
 static void cpad_out_callback(struct urb *urb)
-#else
-static void cpad_out_callback(struct urb *urb, struct pt_regs *regs)
-#endif
 {
 	struct synusb *synusb;
 
@@ -465,11 +430,7 @@
 		return;
 	err("usb_submit_urb bulk in failed, error %d", synusb->error);
 error:
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
 	cpad_in_callback(urb);
-#else
-	cpad_in_callback(urb, regs);
-#endif
 }
 
 /* send out and in urbs synchronously */
@@ -620,11 +581,7 @@
 	return retval;
 }
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
-static void cpad_light_off(void *work)
-#else
 static void cpad_light_off(struct work_struct *work)
-#endif
 {
 	struct synusb *synusb = container_of(work, struct synusb, flash.work);
 
@@ -751,9 +708,6 @@
 static struct usb_class_driver cpad_class = {
 	.name =		"usb/cpad%d",
 	.fops =		&cpad_fops,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
-	.mode =		S_IFCHR | S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP,
-#endif
 	.minor_base =	USB_CPAD_MINOR_BASE,
 };
 
@@ -991,9 +945,6 @@
 }
 
 static struct usb_driver synusb_driver = {
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)
-	.owner =	THIS_MODULE,
-#endif
 	.name =		"synaptics-usb",
 	.probe =	synusb_probe,
 	.disconnect =	synusb_disconnect,
